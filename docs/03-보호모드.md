## 보호모드 전환
### 1. GDTR 설정
프로세서에 GDT 정보를 설정하기 위해, lgdt 명령어로 GDT가 존재하는 메모리 주소를 GDTR에 넣을 수 있다.
GDT 자체는 그저 디스크립터의 집합이므로, 프로세서에 GDT의 시작 어드레스와 크기 정보를 가진 자료구조가 필요하다. 이를 GDTR이라고 한다.
GDTR은 첫 2바이트가 크기고, 뒤의 4바이트가 32비트 기준 주소로, 선형주소이다. 따라서 세그멘테이션이 일어나지 않는다. 현재 우리의 코드는 실제 메모리에서 0x10000에서 시작하는데, 코드 자체는 0x0에서 시작하는 것으로 되어 있으므로, 0x10000을 더해주어야 한다.
### 2. CR0 컨트롤 레지스터 설정
CR0 레지스터를 수정하여 실제로 리얼모드에서 보호모드로 전환할 수 있다.

이 때, 리얼모드임에도 불구하고 eax 레지스터를 사용할 수 있는데, 이는 보호모드를 지원하는 CPU면, 리얼모드에서도 (바이너리 코드에서) 0x66 접두사를 붙여서 eax에 접근할 수 있다. 다만, NASM에서는 자동으로 처리해주므로 우리는 그냥 eax를 사용하면 된다.
### 3. jmp
jmp 명령어를 통하여 CS 레지스터를 갱신하고 32비트 코드로 변경한다.

이 때, 보호모드에서 CS 레지스터는 메모리 영역을 가리키는 것이 아니라, GDT 내에서의 오프셋을 의미하므로, 예를 들어 GDT의 첫 널 디스크립터 다음 세그먼트 디스크립터를 고르고 싶다면, 8로 설정하면 된다.

### 참고
보호모드에서 논리주소는 16비트의 세그먼트 셀렉터와 32비트 오프셋으로 나뉨.

#### Near Jump vs Far Jump
```
jmp 0x1234
```
Near Jump는 CS를 바꾸지 않음. 현재 CS에서의 오프셋만을 바꿈

```
jmp 0x08:0x1234
```
Far jump
CS 레지스터를 먼저 바꾸고, 그 안에서의 오프셋을 바꿈.

